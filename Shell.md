# 1.特殊变量

| 序号 | 符号 | 作用                                                         | 示例                                              |
| ---- | ---- | ------------------------------------------------------------ | ------------------------------------------------- |
| 1    | $0   | 当前脚本名称，如果执行脚本包含了路径，那么就包括路径脚本路径 |                                                   |
| 2    | $n   | 传递给脚本的第几个参数，第一个参数是`$1`，当n大于9时，使用`{}`括起来，例如`${10}` |                                                   |
| 3    | $#   | 传递给脚本或函数的总参数个数                                 |                                                   |
| 4    | $*   | 传递给脚本或函数的所有参数，不加引号等同于`$@`；如果给`$*`加上双引号，例如**`“$*”`则表示将所有参数视为单个字符串，相当于“$1 $2 $3”** |                                                   |
| 5    | $@   | 获取当前脚本所有传参的参数，不加引号和`$*`相同；如果给`$@`加上双引号，例如**`“$@”`则表示将所有参数视为单个字符串，相当于“$1“ ”$2“ ”$3” “...”** |                                                   |
| 6    | $?   | 上个命令的退出状态，或者函数的返回值（0为成功，非零为失败）  |                                                   |
| 7    | $$   | 当前脚本的进程号（PID）                                      |                                                   |
| 8    | $!   | 获取上一个在后台的进程的进程号（PID）                        |                                                   |
| 9    | $_   | 获取在此前执行的命令或脚本的最后一个参数                     |                                                   |
| 10   | ~    | 波浪号。和环境变量 $HOME 一样。默认表示当前用户的家目录      | `echo ~` 查看家目录                               |
| 11   | --   | 两个减号，与 ~ 相同，表示当前用户的家目录                    | `cd - -` 回到家目录，但不能 `echo --` 输出        |
| 12   | ~+   | 当前工作目录。和环境变量 $PWD 一样。                         | `echo ~+`可以查看当前目录                         |
| 13   | ~-   | 前一个工作目录。和内部变量 $OLDPWD 一致，和减号一样。        | `echo ~-`可以查看前一个工作目录                   |
| 14   | -    | 减号。和`~-`一样，表示前一个工作目录。                       | `cd -` 回到前一个工作目录，但不能 `echo -` 来查看 |
| 15   | .    | 点号。表示当前目录                                           | `ls .` 查看当前目录内容                           |
| 16   | ..   | 两个点号。表示上一层目录                                     | `ls ..` 查看上一层目录内容                        |
| 17   | *    | 作为匹配文件名的拓展的一个通配符，能自动匹配给定目录下的每一个文件 |                                                   |

# 2.替换符

替换符分为命令替换符和变量替换符。

## 变量替换符

| 符号    | 作用                                                         | 示例                                                         |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| $       | 美元符放在变量前用于取变量的值                               | `echo $PATH` 打印环境变量 PATH 的值                          |
| ${}     | 美元符加上大括号，大括号中放变量的名称，也是用于读取变量的值 | `echo ${PATH}path`,访问变量PATH，而不是变量 PATHpath，注意和上面 $ 的区别 |
| ${:-}   | 用法`${var:-word}`。表示如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。 |                                                              |
| ${:+}   | 用法`${var:+word}`。如果变量 var 被定义，那么返回 word，但不改变 var 的值。 |                                                              |
| ${:=}   | 用法${var:=word}。如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。 |                                                              |
| ${:?}   | 用法`${var:?message}`。如果变量 var 为空或已被删除（unset），那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。 |                                                              |
| ${#}    | 用法`${#var}`。获取字符串变量 var 的长度                     | `string="abcd"; echo ${#string}` 输出 4                      |
| ${:}    | 字符串提取，用法${var:n}。若n为正数，n从0开始，表示在变量var中提取第n个字符到末尾的所有字符。若n为负数，提取字符串最后面n的绝对值个字符，使用时在冒号后面加空格或一个算术表达式或整个num加上括号，如${var: -2}、${var:1−3}或 ${var:(-2)}均表示提取字符串最后两个字符。 | `a="abcde";echo ${a:1-4}`输出 cde。                          |
| ${::}   | 字符串提取，用法${var:n1:n2}。                               | `string="tencent is a great company";echo ${string:1:4}`输出 ence。 |
| {,}     | 顺序扩展，用法`${value1,value2,value3}`，逗号分隔一般用于文件列表的扩展。 | `echo {a,b}.txt`输出a.txt b.txt                              |
| {..}    | 顺序扩展，用法`${value1..value2}`，双点号分隔一般用于文件列表的扩展。 | `echo {a..d}.txt`输出 a.txt b.txt c.txt d.txt                |
| ${#}    | 模式匹配截断，不改变原变量。用法`${var#pattern}`，在 var 中查找给定的模式 pattern，把 var 中的内容去掉左边最短的匹配模式。**从最开始删除匹配最短** | `var=testcase; echo ${var#*s}`输出 tcase。匹配到了`tes`      |
| ${##}   | 模式匹配截断，不改变原变量。用法`${var##pattern}`，在 var 中查找给定的模式 pattern，把 var 中的内容去掉左边最长的匹配模式。**表示从开头删除匹配最长** | `var=testcase; echo ${var##*s} `输出 e。匹配到了`testcas`    |
| ${%}    | 模式匹配截断，不改变原变量。用法`${var%pattern}`，在 var 中查找给定的模式 pattern，把 var 中的内容去掉右边最短的匹配模式。**表示从结尾删除匹配最短** | `var=testcase;echo ${var%s*e} `输出 testca。匹配到了`se`     |
| ${%%}   | 模式匹配截断，不改变原变量。用法`${var%%pattern}`，在 var 中查找，把 variable 中的内容去掉右边最长的匹配模式。**表示从结尾删除匹配最长** | `var=testcase;echo ${var%%s*e}`输出 te。匹配到了`stcase`     |
| ${/ /}  | 模式匹配替换，不改变原变量。用法`${var/pattern/pattern}`将 var 字符串的第一个匹配的 pattern 替换为另一个 pattern。 | `var=/home/centos;echo ${var/o/h}`输出 /hhme/centos          |
| ${// /} | 模式匹配替换，不改变原变量。用法`${var//pattern/pattern}`表示将 var 字符串中的所有能匹配的 pattern 替换为另一个pattern。 | `var=/home/centos;echo ${var//o/h}`输出 /hhme/cenths。       |
| $[]     | 整数扩展，在方括号内执行整数表达式并返回结果。               | `a=3;b=7;echo $[$a+$b]`输出 10                               |
| a*c     | 表示匹配字符串，\*表示所有，a\*c表示匹配开头为a，中间为任意多个字符，结尾为c的字符串 |                                                              |

**以上匹配规则不适合于正则表达式**

## 命令替换符

| 特殊符号 | 作用                                                         | 示例         |
| -------- | ------------------------------------------------------------ | ------------ |
| $()      | 命令替换符，用于执行命令，替换命令的输出结果                 | echo $(date) |
| \``      | 一对反引号，在键盘的 Tab 键上面。注意与单引号的区别，其作用与 $() 相同 | echo \`date` |

## 转义字符

| 符号 | 作用                                                         | 示例                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| \    | 反斜杠，用于转义                                             |                                                              |
| \a   | 警报，响铃                                                   |                                                              |
| \b   | 退格（删除键）                                               |                                                              |
| \f   | 换页(FF)，将当前位置移到下页开头                             |                                                              |
| \n   | 换行                                                         |                                                              |
| \r   | 回车                                                         |                                                              |
| \t   | Tab                                                          |                                                              |
| \v   | 垂直制表符                                                   |                                                              |
| \c   | 不产生进一步的输出。也就是说在 \c 后，这一行后面的内容都不会输出，直接删掉了 | `echo -e "this is line1 \c these word will disappear"`，输出 this is line1 |

## 字符串符号

| 符号 | 作用                                                         | 示例                                     |
| ---- | ------------------------------------------------------------ | ---------------------------------------- |
| ‘’   | 两个单引号。单引号括住的内容，被视为常量字符串，引号内禁止变量扩展，并且单引号字符串中不能出现单引号（对单引号使用转义符后也不行）强引用，引号里是什么全输出什么，不解析 | `echo '$PATH'`，输出字符串 $PATH         |
| “”   | 两个双引号。双引号包围的内容允许变量扩展，可以包含双引号，但需要转义。弱引用，先解析变量再输出 | `echo "$PATH"`，输出环境变量 PATH 的内容 |

## 功能符

### 语法功能符号

| 符号  | 作用                                                         | 示例                                                         |
| ----- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `#`   | 井号。注释符号。在shell文件的行首，作为include标记，#!/bin/bash;其他地方作为注释使用。 |                                                              |
| `;`   | 分号。语句的分隔符。在shell文件一行写多条语句时，使用分号分割。 |                                                              |
| `;;`  | 双分号。在使用 case 选项时，作为每个选项的终结符。在 Bash version 4+ 的时候，还可以使用`[;;&]`或 `[;&]` |                                                              |
| `/`   | 斜杠。路径的分隔符，路径中仅有一个斜杆表示根目录，以斜杆开头的路径表示从根目录开始的路径。 |                                                              |
| `|`   | **管道。管道是类 Unix 系统都有的概念，是非常基础、非常重要的一个概念。它的作用是将管道前（左边）命令产生的输出作为管道后（右边）命令的输入。** | `less fiel |wc -l` 用于统计文件的行数                        |
| `>`   | 输出重定向。                                                 | `echo lvlv>file`,将标准输出重定向文件file中去，如果文件存在则覆盖，不能存在则创建。不指定输出的内容，`>file`，则清空文件。 |
| `>>`  | 输出重定向追加符。                                           | `echo lvlv 1>>file`,将标准输出重定向文件file的最后面，不会覆盖file原有内容 |
| `>&`  | 输出重定向等同符，作用于文件描述符，即左右两边的操作数是文件描述符 | `echo lvlv>file 2>&1`,标准输出重定向到文件file中，标准错误输出与标准输出重定向一致 |
| `&>`  | 标准输出和标准错误输出重定向符。                             | `echo lvlv &>file`,标准输出和标准错误输出都重定向到文件file中，与`echo lvlv 1>file 2>&1` 功能相同 |
| `<`   | 输入重定向                                                   | `test.sh < file`,脚本test.sh需要read的地方会从文件file读取   |
| <<    | 用法格式：cmd << text。从命令行读取输入，直到一个与 text 相同的行结束。除非使用引号把输入括起来，此模式将对输入内容进行 Shell 变量替换。如果使用 <<- ，则会忽略接下来输入行首的 tab，结束行也可以是一堆 tab 再加上一个与 text 相同的内容。 |                                                              |
| `<&`  | 标准输入重定向等同符，作用于文件描述符，即左右两边的操作数是文件描述符 | `cmd <& m`,将文件描述符m作为cmd的输入，省略了标准输入描述符1，即等价于`cmd 1<&fd` |
| `>&-` | 关闭某个输出文件描述符。用法格式：exec fd>&-                 | `exec >&-`或`exec 0>&-`，关闭标准输出                        |
| `<&-` | 关闭某个输入文件描述符。用法格式：exec fd>&-                 | `exec <&-`或`exec 1<&-`关闭标准输入                          |
| `&`   | 与号。如果命令后面跟上一个&符号，这个命令将会在后台运行。    | 使用格式：command&                                           |
| `/`   | 斜杠。主要有两种作用。 （1）作为路径的分隔符，路径中仅有一个斜杆表示根目录，以斜杆开头的路径表示从根目录开始的路径； （2）在作为运算符的时候，表示除法符号。 |                                                              |
| `()`  | 一对小括号。主要有两种用法： （1）命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。 （2）用于初始化数组。如 array=(a b c d) |                                                              |
| `{}`  | 一对大括号。代码块标识符，一般用于函数定义时表明函数体。     |                                                              |
| `<<<` | 三个小于号。作用就是将后面的内容作为前面命令的标准输入。     | `grep a <<< "$VARIABLE"`，意思就是在 VARIABLE 这个变量值里查找字符 a。 |
| `>|`  | 大于号与竖杠。功能同 >，但即便设置了 noclobber 属性时也会强制复盖file文件。shell设置了noclobber属性表明已存在的文件不能被重定向输出覆盖。 |                                                              |
| `<>`  | 标准输入与输出重定向运算符                                   | `exec 6<>filename`，通过 exec 命令，以读写的方式将文件描述符 6 绑定到指定文件。 |

### 命令功能符号

| 符号 | 作用                                                         | 示例 |
| ---- | ------------------------------------------------------------ | ---- |
| .    | 点号。1.相当于bash内建命令source，如：#!/bin/bash;. data-file#包含data-file;2.作为文件名的一部分，在文件名的开头，表示该文件为隐藏文件，ls 一般不显示出来（ls -a 可以显示）;3.作为目录名，一个点代表当前目录，两个点号代表上层目录（当前目录的父目录）。注意，两个以上的点不出现，除非你用引号（单/双）包围作为点号字符本身；4.正则表达式中，点号表示任意一个字符。 |      |
| ：   | 冒号。是 Shell 的空命令，什么也不做，但是返回 true。用法比较多，主要有：（1）可做 while 死循环的条件；（2）占位符，if 某一分支什么都不做的时候；（3）域分隔符，比如环境变量 PATH 或 passwd 中，都有冒号作为域分隔符的存在；（4）清空文件。因为冒号不向标准输出打印任何内容，所以可以用来清空文件，如 :>file（5）配合${:=}给未定义或为空的变量赋值，示例：: ${abc:=1234};echo $abc，输出 1234 |      |

## 运算符

| 符号 | 含义                                                         | 示例                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| =    | 赋值                                                         | `a=$b`，将把变量 b 的值赋给 a                                |
| (()) | 双小括号算术运算符，用于 expr 命令的替代，即支持算术表达式，而无需 expr 命令 | `for((i=0;i<10;++i))`或者`((out=$a*$b))`或者`if(($a==$b));then ... fi`，无需添加空格了，更加符合 C 的编程语法 |

### 关系运算符

| 符号 | 作用                                                       | 示例                                                         |
| ---- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| []   | 一对方括号，用于判断条件是否成立                           | `[ $a == $b ]`，注意添加 4 个空格                            |
| [[]] | 两对方括号，是对 [] 的扩展，可使用 <、>、&&、\|\| 等运算符 | `[[ $a>$b ]]`，只需要添加左右两边两个空格。注意：使用 == 与 != 时，仍需要 4 个空格 |
| -eq  | 检测两个数是否相等，相等返回 true                          | `[ $a -eq $b ]` 返回 true                                    |
| ==   | 检测两个数是否相等，作用同-eq                              | `[ $a == $b ]` 返回 true                                     |
| -ne  | 检测两个数是否相等，不相等返回 true                        | `[ $a -ne $b ]` 返回 true                                    |
| !=   | 作用同 -ne                                                 | `[ $a != $b ]` 返回 true                                     |
| -gt  | 检测左边的数是否大于右边的，如果是，则返回 true            | `[ $a -gt $b ]` 返回 false                                   |
| -lt  | 检测左边的数是否小于右边的，如果是，则返回 true            | `[ $a -lt $b ]` 返回 true                                    |
| -ge  | 检测左边的数是否大等于右边的，如果是，则返回 true          | `[ $a -ge $b ]` 返回 false                                   |
| -le  | 检测左边的数是否小于等于右边的，如果是，则返回 true        | `[ $a -le $b ]` 返回 true                                    |

### 逻辑运算符

| 符号 | 作用                                                         | 示例                                     |
| ---- | ------------------------------------------------------------ | ---------------------------------------- |
| !    | 非运算，表达式为 true 则返回 false，否则返回 true。          | [ ! false ] 返回 true                    |
| -o   | 或运算，有一个表达式为 true 则返回 true。                    | `[ $a -lt 20 -o $b -gt 100 ]` 返回 true  |
| -a   | 与运算，两个表达式都为 true 才返回 true。                    | `[ $a -lt 20 -a $b -gt 100 ]` 返回 false |
| ｜｜ | 或运算符，与 && 作用相反，也有两种用法。1）用于条件判断，需与 [[]] 配合使用。两个表达式有一个为 true 就返回 true。2）命令连接：command1 \|\|command2，左边的命令返回 false（即返回非 0，执行失败），右边的命令才能够被执行 | `[[ $a < 20 ||$a > 19 ]]` 返回 true      |
| &&   | 与运算符，有两种用法。（1）用于条件判断，需与 [[]] 配合使用。两个表达式都为true才返回true。（2）命令连接。command1 && command2。左边的命令返回真（即返回 0，成功被执行），右边的命令才能够被执行。 | `[[ $a < 20 && $a > 20 ]]` 返回 false    |

### 字符串运算符

| 符号 | 作用                                                       | 示例                                                     |
| ---- | ---------------------------------------------------------- | -------------------------------------------------------- |
| =    | 检测两个字符串是否相等，相等返回 true                      | `[ "$a" = "$b" ]` 返回 false                             |
| !=   | 检测两个字符串是否相等，不相等返回 true。                  | `[ "$a" != "$b" ]` 返回 true                             |
| -z   | 检测字符串长度是否为 0，为 0 返回 true。                   | `[ -z "$a" ]` 返回 false                                 |
| -n   | 检测字符串长度是否为 0，不为 0 返回 true。                 | `[ -n "$a" ]` 返回 true                                  |
| str  | 检测字符串是否为空，不为空返回 true。                      | `[ "$a" ]` 返回 true                                     |
| =~   | 正则表达式匹配运算符，用于匹配正则表达式的，配合 [[]] 使用 | `[[ ! $file =~ check$ ]]` 判断 $file 是否是以 check 结尾 |

### 文件运算符

| 符号 | 作用                                                        | 示例                                           |
| ---- | ----------------------------------------------------------- | ---------------------------------------------- |
| -b   | 文件存在且是块设备文件                                      | [ -b /dev/vda1 ] 返回 true                     |
| -c   | 文件存在且是字符设备文件                                    | [ -c /dev/stdin ] 返回 true                    |
| -d   | 文件存在且是目录                                            | [ -d / ] 返回 true                             |
| -e   | 文件（包括目录）是否存在                                    | [ -e / ] 返回 true                             |
| -f   | 文件存在且是普通文件（既不是目录，也不是设备文件）          | [ -f /etc/passwd] 返回 true                    |
| -g   | 文件存在且设置了 SGID 位                                    | [ -g /usr/bin/passwd ] 返回 false              |
| -G   | 文件存在且属于有效组 ID                                     | [ -G /etc/passwd ] 返回 true                   |
| -h   | 文件存在且是软链接。同 -L                                   | [ -h /etc/passwd ] 返回 false                  |
| -k   | 文件存在且设置了粘着位（Sticky Bit）                        | [ -k /tmp ] 返回 true                          |
| -L   | 文件存在且是软链接。同 -h                                   | [ -L /etc/passwd ] 返回 false                  |
| -O   | 文件存在且属于有效用户ID                                    | [ -O /etc/passwd ] 返回 true                   |
| -p   | 文件存在且是具名管道                                        | [ -p /etc/passwd ] 返回 false                  |
| -r   | 文件存在且可读                                              | [ -r /etc/passwd ] 返回 true                   |
| -s   | 文件存在且不为空                                            | [ -s /etc/passwd ] 返回 true                   |
| -S   | 文件存在且是套接字（socket）                                | [ -s /etc/passwd ] 返回 false                  |
| -u   | 文件存在且设置了 SUID 位                                    | [ -s /usr/bin/passwd ] 返回 true               |
| -w   | 文件存在且可写                                              | [ -w /etc/shadow ] 返回 false                  |
| -x   | 文件存在且可执行                                            | [ -x /usr/bin/passwd ] 返回 true               |
| -ef  | 两个文件是否为同一个文件。主要看文件设备号与 inode 是否一致 | [ /usr/bin/passwd -ef /etc/passwd ] 返回 false |
| -nt  | 文件 FILE1 是否比 FILE2 新（修改时间新）                    | [ /usr/bin/passwd -nt /etc/passwd ] 返回 false |
| -ot  | 文件 FILE1 是否比 FILE2 旧（修改时间旧）                    | [ /usr/bin/passwd -ot /etc/passwd ] 返回 true  |

这里附带说明一下 Linux 下文件的类型。

```shell
- 普通文件
d 目录
b 块设备
c 字符设备
p 命名管道
l 符号链接
s 套接字
1234567
```

# 第二章

```shell
cat /dev/null>message #删除命令
```

只有开头才可以解释脚本内容

```
#!/bin/bash
#!/bin/sh
```

Shell脚本执行方法

```shell
bash script-name # 执行脚本会启动新的Shell执行
source script-name
. script-name #source 和 . 在当前的Shell执行source和.加载并执行相关脚本文件中的命令及语句，
#而不是产生一个子shell来执行文件命令，读入脚本并执行脚本
```

# 第三章

设置环境变量

```shell
export 变量=value
变量名=value ； export 变量名
declare -x 变量名=value;
```

env显示默认环境变量

set也可以显示环境变量

unset 消除本地变量和环境变量

## 环境变量的知识小结

变量名通常要大写

变量可以在自身的Shell及子Shell中使用

常用export来定义环境变量

执行env默认可以显示所有的环境变量名以及对应的值

输出时用“$ 变量名”，取消时用“unset 变量名”

书写crond定时任务时要注意，脚本要用到的环境变量最好新啊在所执行的Shell脚本中重新定义

如果希望环境变量永久生效，则可以将其放在用户环境变量文件或全局环境变量文件里

## 把一个命令的结果作为变量的内容赋值的方法

```shell
变量名=`ls`
变量名=$(ls) #推荐
```

## 局部变量定义及赋值的经验小结

**常规普通变量定义：**

若变量内容为连续的数字或字符串，赋值时，变量内容两边不加引号

变量的内容很多时，如果有空格且希望解析内容中的变量，加双引号

希望原样输出变量中的内容时就用单引号引起内容进行赋值

要使用反引号将赋值的命令括起来或使用$()括起来

**变量输出方法：**

使用 $ 变量名

```shell l
echo $ 变量名
```

在变量前加$相当于取变量的值，$ 变量 和 ${变量}写法不同，但是内容相似

# 第四章

${1..15} 1-15 15个变量

```shell
dirname $0 #脚本路径
basename $0 #脚本名称
```

# 第五章

## 双小括号数值运算命令

(()) 表达式在命令执行时不需要加$符号，直接使用((6%2))形式即可，但是如果需要输出，就要加$符号

(()) 里的所有字符之间没有空格、有一个或多个空格都不会影响结果

```shell
echo "${firstnum}${operators}${secondnum}=$((${firstnum}${operators}${secondnum}))"
```

## expr

运算符及用于计算的数字左右都至少有一个空格，否则会报错

使用乘号时，必须用反斜线屏蔽其特点含义，



标准输入stdin，标准输出stdout、标准错误stderr，三个系统文件的文件描述符分别为0，1、2。进程需要的输入来自stdin文件、进程的标准输出是送到stdout文件、标准错误输出是送到stderr文件。而stdout(1)/stderr(2)默认是输出到终端

```shell
echo log > /dev/null 2>&1
```

**/dev/null** ：代表空设备文件
**>** ：代表重定向到哪里，例如：echo "123" > /home/123.txt
**1** ：表示stdout标准输出，系统默认值是1，所以">/dev/null"等同于"1>/dev/null"
**2** ：表示stderr标准错误
**&** ：表示等同于的意思，2>&1，表示2的输出重定向等同于1

**1 > /dev/null 2>&1** 语句含义：
1 > /dev/null ： 首先表示标准输出重定向到空设备文件，也就是不输出任何信息到终端，说白了就是不显示任何信息。
2>&1 ：接着，标准错误输出重定向（等同于）标准输出，因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件

```shell
cmd >a 2>a 和 cmd >a 2>&1 为什么不同？
cmd >a 2>a    ： stdout和stderr都直接送往文件 a ，a文件会被打开两遍，由此导致stdout和stderr互相覆盖。
cmd >a 2>&1  ： stdout直接送往文件a ，stderr是继承了FD1的管道之后，再被送往文件a 。a文件只被打开一遍，就是FD1将其打开。

两者的不同点在于：

cmd >a 2>a 相当于使用了FD1、FD2两个互相竞争使用文件 a 的管道；
cmd >a 2>&1 只使用了一个管道FD1，但已经包括了stdout和stderr。
从IO效率上来讲，cmd >a 2>&1的效率更高。
```

# 第六章

## test条件测试

| 测试方法                  |
| ------------------------- |
| 语法一：test <测试表达式> |
| 语法二：[ <表达式> ]      |
| 语法三：[[ <表达式> ]]    |
| 语法四：(( <表达式> ))    |

“-a” 和 “-o” 逻辑操作符号需要在 [] 中

“&&” 和 “||” 逻辑操作符号可用于[[]] 或(()) 中，也可以在外部连接多个[]

注意，在[] 和[[]]的两端及比较符号的两端，必须有空格，但是对于(())不需要

# 第七章

每一个if条件语句都是if开头，并带有then，然后以fi结尾，elif也需要有then。也就是if出现就需要then进行连接。

```
|wc -l #计算文件的byte数，l:listen n:num t:tcp u:udp p:process
```

# 第八章

```
function 函数名() {
	指令...
	return n
}

function 函数名{

}

函数名() {

}
```

$# 参数为shell命令背后紧跟的命令

read a,b 不可以使用`$#`判定

# 第九章

```
case “变量” in
	值1）
		指令1...
		;;
	值2)
		指令2...
		;;
	*)
		指令3...
esac
```

# 第十章

```
while <条件表达式>
do
	指令...
done
```



| 用法          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| sh while.sh & | 将脚本放置到后台运行                                         |
| ctrl+c        | 停止执行当前脚本或任务                                       |
| ctrl+z        | 暂停执行当前脚本或任务                                       |
| bg            | 将当前脚本放置后台运行，bg理解为background                   |
| fg            | 将当前脚本放置前台运行，fg理解为frontground，fg加任务编号调出对应的脚本任务 |
| jobs          | 查看当前执行的任务和脚本                                     |
| kill          | 关闭执行的脚本任务，kill % 任务编号的形式关闭脚本            |

```shell
jobs #查看任务号
kill %x #关闭执行的脚本任务
```

读取文件，按行读取文件

```shell
exec <FILE
sum = 0
while read line
do
	cmd
done	
```

expr使用方法，可以判定扩展名

```shell
expr "$file" : ".*\.log" &>dev/null
```

## 小结

While循环的特长是执行守护进程，以及实现我们希望循环持续执行不退出的应用

case语句可以使用if代替，在系统启动脚本时可以传输少量固定规则字符串的情况下多使用case，其他普通判定多用if。

if语句和for语句最常用，其次是while（守护进程）、case（服务启动脚本）

条件表达式；用于简短的条件判断及输出

if取值判断，多用于不同数值较少的情况

for最常用于正常的循环处理中

# 第十一章

for循环

```
for 变量名 in 变量取值列表
do
	指令...
done	

for((exp1; exp2; exp3))
do
	指令...
done
```

select 循环语句

```shell
select 变量名 [ in 菜单取值列表 ]
do
	指令...
done
```

# 第十二章

| 命令       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| break n    | 如果省略n，则表示跳出整个循环，n表示跳出循环的层数           |
| continue n | 如果省略n，则表示跳过本次循环，直接进入下一次循环。n表示退到第n层继续循环 |
| exit n     | 退出当前shell程序，n为上一次程序执行的返回值     $?   接受n值 |
| return n   | 用于在函数里作为函数的返回值，以判断函数执行是否正确           $?   接受n值 |

# 第十三章

语法

```shell
array=(value1 value2 value3...)
# 使用*或@可以得到整个数组的内容
# 用${# 数组名 [@或*]}可以得到数组的长度
# unset 数组[ 下标 ] 清除数组

array=(1 2 3) # 静态数组
array=($(ls)) # 动态数组
array[3]=4 # 为数组赋值
${array[@]} ${array[*]} # 打印所有元素
${#array[@]} ${#array[*]} #打印数组长度
${array[i]} # 打印数组下标
```

# 第十四章

全局变量使用export定义

# 第十五章

函数1（）

函数2（）

main（）

main $*

命令调试

```shell
set -n # 读命令但是不执行
set -v # 显示读取所有行
set -x # 显示所有命令及其参数
```

